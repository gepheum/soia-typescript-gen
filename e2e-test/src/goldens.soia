
struct UnitTest {
  test_number: int32;
  assertion: Assertion;
}

enum Assertion {
  struct BytesEqual {
    actual: BytesExpression;
    expected: BytesExpression;
  }
  bytes_equal: BytesEqual;

  struct StringEqual {
    actual: StringExpression;
    expected: StringExpression;
  }
  string_equal: StringEqual;

  struct ValueBundle {
    value: TypedValue;
    expected_dense_json: string;
    expected_readable_json: string;
    alternative_jsons: [StringExpression];
    expected_bytes: bytes;
    alternative_bytes: [BytesExpression];
    expected_type_descriptor: string?;
  }
  value_bundle: ValueBundle;
}

enum StringExpression {
  literal: string;
  to_dense_json: TypedValue;
  to_readable_json: TypedValue;
  point_to_dense_json: PointExpression;
  point_to_readable_json: PointExpression;
}

enum BytesExpression {
  literal: bytes;
  to_bytes: TypedValue;
  point_to_bytes: PointExpression;
}

enum TypedValue {
  bool: bool;
  int32: int32;
  int64: int64;
  uint64: uint64;
  float32: float32;
  float64: float64;
  timestamp: timestamp;
  string: string;
  bytes: bytes;
  bool_optional: bool?;
  ints: [int32];
  point: Point;
  color: Color;
  round_trip_dense_json: TypedValue;
  round_trip_readable_json: TypedValue;
  round_trip_bytes: TypedValue;
}

enum PointExpression {
  literal: Point;
  from_json_keep_unrecognized: StringExpression;
  from_json_drop_unrecognized: StringExpression;
  from_bytes_keep_unrecognized: BytesExpression;
  from_bytes_drop_unrecognized: BytesExpression;
}

struct Point {
  x: int32;
  removed;
  y: int32;
}

struct Color {
  r: int32;
  g: int32;
  b: int32;
  removed;
}

const UNIT_TESTS: [UnitTest] = [
  {
    test_number: 1000,
    assertion: {
      kind: "value_bundle",
      value: {
        value: {
          kind: "bool",
          value: true,
        },
        expected_dense_json: "1",
        expected_readable_json: "true",
        alternative_jsons: [
          {
            kind: "literal",
            value: "3.14",
          },
          {
            kind: "literal",
            value: "-1",
          },
          {
            kind: "literal",
            value: '"-Infinity"',
          },
        ],
        expected_bytes: "hex:736f696101",
        alternative_bytes: [
          {
            kind: "to_bytes",
            value: {
              kind: "float32",
              value: 3.14,
            },
          },
        ],
        expected_type_descriptor: "{\n  \"type\": {\n    \"kind\": \"primitive\",\n    \"value\": \"bool\"\n  },\n  \"records\": []\n}",
      },
    },
  },
  {
    test_number: 1001,
    assertion: {
      kind: "value_bundle",
      value: {
        value: {
          kind: "bool",
          value: false,
        },
        expected_dense_json: "0",
        expected_readable_json: "false",
        expected_bytes: "hex:736f696100",
        alternative_jsons: [
          {
            kind: "literal",
            value: "0.0",
          },
          {
            kind: "literal",
            value: "-0.0",
          },
        ],
        alternative_bytes: [],
        expected_type_descriptor: null,
      }
    }
  },
  {
    test_number: 1002,
    assertion: {
      kind: "value_bundle",
      value: {
        value: {
          kind: "timestamp",
          value: "1970-01-01T00:00:00.000Z",
        },
        expected_dense_json: "0",
        expected_readable_json: '{\n  "unix_millis": 0,\n  "formatted": "1970-01-01T00:00:00.000Z"\n}',
        expected_bytes: "hex:736f696100",
        alternative_jsons: [
          {
            kind: "literal",
            value: "0.0",
          },
        ],
        alternative_bytes: [],
        expected_type_descriptor: "{\n  \"type\": {\n    \"kind\": \"primitive\",\n    \"value\": \"timestamp\"\n  },\n  \"records\": []\n}",
      }
    }
  },
  {
    test_number: 1003,
    assertion: {
      kind: "value_bundle",
      value: {
        value: {
          kind: "timestamp",
          value: "2023-08-25T21:30:34.586Z",
        },
        expected_dense_json: "1692999034586",
        expected_readable_json: '{\n  "unix_millis": 1692999034586,\n  "formatted": "2023-08-25T21:30:34.586Z"\n}',
        expected_bytes: "hex:736f6961efda269b2e8a010000",
        alternative_jsons: [],
        alternative_bytes: [
          {
            kind: "to_bytes",
            value: {
              kind: "float64",
              value: 1692999034586.1,
            },
          },
        ],
        expected_type_descriptor: null,
      }
    }
  },
];
